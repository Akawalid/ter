module Graph
  use int.Int
  use list.List
  use list.Length
  use list.Mem
  use array.Array

  type t = array (list int)

  let function size (g : t) : int
  = Array.length g

  let function e_size g =
    let rec aux i n =
      requires {i>=0}
      variant{Array.length g - i} 
      if i >= Array.length g then n
      else aux (i+1) (n + Length.length g[i])
    in
    aux 0 0

  let create (n : int ) : t
  requires { n >= 0 }
  ensures { Array.length result = n }
  ensures { forall i. 0 <= i < Array.length result -> result[i] = Nil }
  = Array.make n Nil

  let add_e (g : t) (s1 : int) (s2 : int) : unit
  requires { 
    s1 >= 0 /\ s2 >= 0 /\
    s1 < Array.length g /\ 
    s2 < Array.length g
  }
  ensures {
    forall s: int. 0 <= s < Array.length g -> s <> s1 -> g[s] = (old g)[s]
  }
  ensures {
    g[s1] = (Cons s2 ((old g)[s1]))
  }
  =
    g[s1] <- Cons s2 g[s1]

  predicate safe_neighbours (l: list int)(g: t) = 
    forall e: int. mem e l -> 0 <= e < Array.length g

  predicate safe_graph (g: t) = 
    forall i: int. 0 <= i < Array.length g -> safe_neighbours g[i] g

  let function succ (g : t) (v : int) : list int
  requires { 0 <= v < Array.length g }
  requires { safe_graph g}
  ensures { forall n: int. mem n result -> 0 <= n < Array.length g } 
  ensures { result = g[v] }
  = g[v]

end

module Path
  use ref.Ref
  use int.Int
  use list.Length as L
  use list.Mem
  use list.List
  use list.NthNoOpt as Nth
  use array.Array
  clone Graph   
  use array.NumOf as N

  type path = list int

 predicate path (g: Graph.t) (x y: int) (p: path)
   = 1 <= L.length p /\ x = Nth.nth 0 p /\ y = Nth.nth (L.length p - 1) p /\
     (forall i. 0 <= i < L.length p -> 0 <= Nth.nth i p < Graph.size g) /\
     (forall i. 0 <= i < L.length p - 1 -> mem (Nth.nth (i+1) p) (Graph.succ g (Nth.nth i p)))

 lemma path_extension: forall g: Graph.t, v j i: int, p: path.
  0 <= v < Graph.size g -> 0 <= j < Graph.size g -> 
  mem j (Graph.succ g v) -> path g j i p -> 
   path g v i (Cons v p)
  
  function nv (visited: array bool): int =  N.numof (fun i a -> a = false) visited 0 (Array.length visited)
  
  
  lemma translation: forall a: array bool, i: int, p: int -> bool -> bool. 
  0 <= i < Array.length a -> a[i] ->
  N.numof (fun i _ -> a[i] = false) a 0 (Array.length a) = 
  N.numof (fun i _ -> a[i] = false) a 0 i + 
  N.numof (fun i _ -> a[i] = false) a (i+1) (Array.length a)
  
  lemma numof_update: forall a: array bool, i: int. 
  0 <= i < Array.length a -> a[i] = false ->
  N.numof (fun i _ -> a[i] = false) (a[i <- true]) 0 (Array.length a) =
  N.numof (fun i _ -> a[i] = false) a  0 (Array.length a) - 1
    
  (*lemma numof_update: forall a: array bool, i: int. 
  0 <= i < Array.length a ->
  N.numof (fun i a -> a = false) (a[i <- true]) 0 (Array.length a) 
  = N.numof (fun i' a -> a = if i = i' then true else a = false) a  0 (Array.length a)*)

  let dfs (g: Graph.t) (v: int): (result: list int) =
    requires{ 0 <= v < Array.length g }
    requires { Graph.safe_graph g }
  
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in

    let rec branch v
      requires{0 <= v < Graph.size g }
      ensures { nv visited <= nv (old visited) }
      ensures {
      old visited[v] 
      \/ forall i: int, p: path. path g v i p -> mem i (!accessible)}
      (*ensures { forall i: int, p: path. path g v i p -> visited[i] }*)
      variant{ nv visited, 0 }
      =

      if not (visited[v]) then begin
        visited[v] <- true;
        assert { nv visited < nv (old visited) };
    
        accessible := Cons v !accessible;
        (*assert{ forall i j: int, p:path. 
  mem j (Graph.succ g v) -> path g j i p -> 
  exists p': path. path g v i p' /\ Nth.nth 0 p' = v };*)
        (*assert{ forall i j: int, p:path. mem j (Graph.succ g v) 
        -> path g j i p 
        -> path g v i (Cons v p)};*)
        loop (Graph.succ g v)
      end
    with loop l = 
       requires { safe_neighbours l g }
       ensures {nv visited <= nv (old visited)}
       ensures {
       forall i j: int, p: path. 
       not(old visited[j])
       -> mem j l 
       -> path g j i p -> mem i (!accessible)
       }
       variant{ nv visited, L.length l }
        match l with 
          | Nil -> ()
          | Cons neighbour s -> 
              branch neighbour;
              loop s
        end;
        (*assert {
       forall i j: int, p: path. 
       not(old visited[j])
       -> mem j l 
       -> path g j i p -> mem i (!accessible)
       }*)
      
      in
      branch v;
      !accessible
end
