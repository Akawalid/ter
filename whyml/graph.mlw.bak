module Graph
  use int.Int
  use list.List
  use array.Array



  type t = array (list int)

  predicate inside (g: t) (s: int) = 0 <= s < Array.length g

  let function size (g : t) : int
  = Array.length g


  let create (n : int ) : t
  requires { n >= 0 }
  ensures { Array.length result = n }
  ensures { forall i. 0 <= i < Array.length result -> result[i] = Nil }
  = Array.make n Nil


  let add_e (g : t) (s1 : int) (s2 : int) : unit
  requires { 
    s1 >= 0 /\ s2 >= 0 /\
    s1 < Array.length g /\ 
    s2 < Array.length g
  }
  ensures {
    forall s: int. 0 <= s < Array.length g -> s <> s1 -> g[s] = (old g)[s]
  }
  ensures {
    g[s1] = (Cons s2 ((old g)[s1]))
  }
  =
    g[s1] <- Cons s2 g[s1]


  let succ (g : t) (v : int) : list int
  requires { v >= 0 && v < Array.length g }
  ensures { result = g[v] }
  = g[v]

end

module Path
  use ref.Ref
  use int.Int
  use list.List
  use array.Array
  clone Graph
  
  let rec function concat l l' =
    match l, l' with 
      | Nil, _ -> l'
      | _, Nil -> l 
      | Cons e l, _ -> Cons e (concat l l')
    end
    
  let rec lemma recConcat (n: int) (l l': list int) =
  (*les elements de l et l' sont exactement les elemetns de concat l l' avec les répétitions*)
    match l, l' with 
      | Nil, _ -> ()
      | Cons e l'', Nil -> recConcat (n-1) l'' l'
      | Cons e l'', _  -> 
        recConcat (n-1) l'' l' ;
        assert {concat l l' = Cons e (concat l'' l')};
        ()
    end
    
  
    
  let dfs g s =
  
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in
    
    let rec loop s neighbours =
      if not (visited[s]) then begin
        visited[s] <- true;
        accessible := Cons s !accessible;
        (*
          BFS: List.concat neighbours (Graph.succ g s)
          DFS: List.concat (Graph.succ g s) neighbours
        *)
        match concat (Graph.succ g s) neighbours with 
          | Cons succ others -> loop succ others 
          | Nil -> ()
          end
      end
    in

    loop s (Graph.succ g s);
    !accessible
end