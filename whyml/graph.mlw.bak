module Graph
  use int.Int
  use list.List
  use array.Array

  predicate list_eq (l1 l2: list int) =
    match l1, l2 with
    | Nil, Nil -> true
    | Cons x1 xs1, Cons x2 xs2 -> x1 = x2 /\ list_eq xs1 xs2
    | _, _ -> false
    end

  type t = array (list int)


  let size (g : t) : int
  = Array.length g


  let create (n : int ) : t
  requires { n >= 0 }
  ensures { Array.length result = n }
  = Array.make n Nil


  let add_e (g : t) (s1 : int) (s2 : int) : unit
  requires { 
    s1 >= 0 && s2 >= 0 &&
    s1 < Array.length g && 
    s2 < Array.length g
  }
  ensures {
    forall s: int. 0 <= s < Array.length g -> s <> s1 -> list_eq g[s] (old g)[s]
  }
  ensures {
    list_eq g[s1] (Cons s2 ((old g)[s1]))
  }
  =
    g[s1] <- Cons s2 g[s1]


  let succ (g : t) (v : int) : int list
  = g.graph.(v)

end
