module Graph
  use int.Int
  use list.List
  use list.Length
  use list.Mem
  use array.Array

  type t = array (list int)

  let function size (g : t) : int
  = Array.length g

  let e_size g =
    let rec aux i n =
      variant{i} 
      if i >= Array.length g then n
      else aux (i+1) (n + Length.length g[i])
    in
    aux 0 0

  let create (n : int ) : t
  requires { n >= 0 }
  ensures { Array.length result = n }
  ensures { forall i. 0 <= i < Array.length result -> result[i] = Nil }
  = Array.make n Nil

  let add_e (g : t) (s1 : int) (s2 : int) : unit
  requires { 
    s1 >= 0 /\ s2 >= 0 /\
    s1 < Array.length g /\ 
    s2 < Array.length g
  }
  ensures {
    forall s: int. 0 <= s < Array.length g -> s <> s1 -> g[s] = (old g)[s]
  }
  ensures {
    g[s1] = (Cons s2 ((old g)[s1]))
  }
  =
    g[s1] <- Cons s2 g[s1]


  let function succ (g : t) (v : int) : list int
  requires { 0 <= v < Array.length g }
  ensures { result = g[v] }
  = g[v]

  predicate safe_graph (g: t) = 
    forall i e: int. 0 <= i < Array.length g -> mem e (succ g i) -> 0 <= e < Array.length g

  inductive path (g :t) (v: int) (v':int)
  =
  | Init: forall u: int, g: t. path g u u
  | Induction: forall u v w: int, g: t. path g u v -> mem w (succ g v) -> path g u w
end

module Path
  use ref.Ref
  use int.Int
  use list.List
  use list.Length
  use list.Mem
  use array.Array
  clone Graph
      
  let dfs (g: Graph.t) (v: int): (result: list int) =
    requires{0 <= v < Graph.size g }
    requires { Graph.safe_graph g }
    
    ensures{forall v' n: int. Graph.path g v v' -> mem v' result} (*correction*)
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in
    
    let rec branch v n =
      requires{0 <= v < Graph.size g } (*peut etre inféré par safe_graph*)
      (*each node is visited as many as it's in_degree
      -> edges size is the variant
      *)
      ensures{forall v': int. Graph.path g v v' -> mem v' !accessible}      
      variant{n}

      assert{Array.length visited = Graph.size g};
      if not (visited[v]) then begin
        visited[v] <- true;
        accessible := Cons v !accessible;
        loop (Graph.succ g v) (n-1)
      end
        
    with loop l n = 
        variant{n}
        match l with 
          | Nil -> ()
          | Cons neighbour s -> branch neighbour (n-1); loop s (n-1)
        end
      in
      branch v (2 * (Graph.size g));
      !accessible
end