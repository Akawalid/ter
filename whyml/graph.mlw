module Graph
  use int.Int
  use list.List
  use list.Length
  use list.Mem
  use array.Array

  type t = array (list int)

  let function size (g : t) : int
  = Array.length g

  let function e_size g =
    let rec aux i n =
      requires {i>=0}
      variant{Array.length g - i} 
      if i >= Array.length g then n
      else aux (i+1) (n + Length.length g[i])
    in
    aux 0 0

  let create (n : int ) : t
  requires { n >= 0 }
  ensures { Array.length result = n }
  ensures { forall i. 0 <= i < Array.length result -> result[i] = Nil }
  = Array.make n Nil

  let add_e (g : t) (s1 : int) (s2 : int) : unit
  requires { 
    s1 >= 0 /\ s2 >= 0 /\
    s1 < Array.length g /\ 
    s2 < Array.length g
  }
  ensures {
    forall s: int. 0 <= s < Array.length g -> s <> s1 -> g[s] = (old g)[s]
  }
  ensures {
    g[s1] = (Cons s2 ((old g)[s1]))
  }
  =
    g[s1] <- Cons s2 g[s1]

  predicate safe_neighbours (l: list int)(g: t) = 
    forall e: int. mem e l -> 0 <= e < Array.length g

  predicate safe_graph (g: t) = 
    forall i: int. 0 <= i < Array.length g -> safe_neighbours g[i] g

  let function succ (g : t) (v : int) : list int
  requires { 0 <= v < Array.length g }
  requires { safe_graph g}
  ensures { forall n: int. mem n result -> 0 <= n < Array.length g } 
  ensures { result = g[v] }
  = g[v]


  inductive path (g :t) (v: int) (v':int)
  =
  | Init: forall u: int, g: t. path g u u
  | Induction: forall u v w: int, g: t. path g u v -> mem w (succ g v) -> path g u w
end

module Path
  use ref.Ref
  use int.Int
  use list.Length
  use list.Mem
  use list.List
  use list.NthNoOpt
  use seq.Seq as S
  clone Graph   
  use array.NumOfEq as N
  
  (*type path = list int

  predicate path (g: Graph.t) (x y: int) (p: path)
  = 1 <= Length.length p /\ x = NthNoOpt.nth 0 p /\ y = NthNoOpt.nth (Length.length p - 1) p  /\
    (forall i. 0 <= i < Length.length p -> 0 <= NthNoOpt.nth i p < Graph.size g) /\
    (forall i. 0 <= i < Length.length p - 1 -> mem (NthNoOpt.nth (i+1) p) (Graph.succ g (NthNoOpt.nth i p)))
  *)

  (*let function nv (visited: array bool): int =  NumOf.numof  (fun i a -> visited[i] = False ) visited 0 (Array.length visited)*)
  function nv (visited: seq bool): int =  N.numof visited false 0 (S.length visited)
  
  let dfs (g: Graph.t) (v: int): (result: list int) =
    requires{ 0 <= v < Graph.size g }
    requires { Graph.safe_graph g }
    (*ensures{forall n: int, p: path. path g v n p -> mem n result}*)
    
    let accessible = ref Nil in
    assert{Array.length visited = Graph.size g};
    let rec branch v (visted: seq bool)
      requires{0 <= v < Graph.size g } (*peut etre inféré par safe_graph*)
      (*each node is visited as many as it's in_degree
      -> edges size is the variant
      *)
      (*ensures{forall n: int, p: path. path g v n p -> mem n !accessible}*)

      variant{ (nv visited, 0) }
      =

        assert{ nv visited = nv (old visited) };
      if not (visited[v]) then begin
        assert{ nv visited = nv (old visited) };
        assert{ visited[v] = false };
        visited[v] <- true;
        assert{ visited[v] = true };
        assert{ nv visited < nv (old visited) };
        accessible := Cons v !accessible;
        loop (Graph.succ g v)
      end
    with loop l = 
       requires { safe_neighbours l g }
       (*ensures{forall n: int, p: path. path g v n p -> mem n !accessible}*)
       variant{ (nv visited, Length.length l) }
        match l with 
          | Nil -> ()
          | Cons neighbour s -> 
              branch neighbour;
              loop s
        end
      in
      branch v;
      !accessible
end
