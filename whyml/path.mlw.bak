module Path
  use ref.Ref
  use int.Int
  use list.Length as L
  use list.Mem
  use list.List
  use list.HdTl as Hdtl
  use list.NthNoOpt as Nth
  use array.Array
  use graph2.Graph   
  use array.NumOf as N
  use array.ArrayEq as AEQ
  use list.NthLengthAppend as APP

  type path = list int

  predicate path (g: Graph.t) (x y: int) (p: path)
  = 1 <= L.length p /\ x = Nth.nth 0 p /\ y = Nth.nth (L.length p - 1) p /\
    (forall i. 0 <= i < L.length p -> 0 <= Nth.nth i p < Graph.size g) /\
    (forall i. 0 <= i < L.length p - 1 -> mem (Nth.nth (i+1) p) (Graph.succ g (Nth.nth i p)))

  lemma path_extension: forall g: Graph.t, v j i: int, p: path.
    0 <= v < Graph.size g -> 0 <= j < Graph.size g -> 
    mem j (Graph.succ g v) -> path g j i p -> 
    path g v i (Cons v p)
    
  
  function nv (visited: array bool): int = N.numof (fun _ a -> a = false) visited 0 (Array.length visited)
  
  lemma numof_concat:
    forall a: array bool, l m r f.
      0 <= l <= m <= r <= Array.length a ->
      N.numof f a l r = N.numof f a l m + N.numof f a m r
 
let lemma numof_update (a: array bool) (i: int) : (array bool)
    requires { 0 <= i < Array.length a }
    requires { a[i] = false }
    ensures { result = a[i<- true] }
    ensures {
      N.numof (fun _ x -> x = false) a 0 i = 
      N.numof (fun _ x -> x = false) result 0 i
    }
    ensures {
      N.numof (fun _ x -> x = false) a (i+1) (Array.length a) = 
      N.numof (fun _ x -> x = false) result (i+1) (Array.length a)
    }
    ensures { 
      N.numof (fun _ x -> x = false) a i (i+1) = 1
    }
    ensures { 
      N.numof (fun _ x -> x = false) result i (i+1) = 0
    }
    ensures{
    N.numof (fun _ x -> x = false) a 0 (Array.length a) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    1
    +
    N.numof (fun _ x -> x = false) a (i+1) (Array.length a)
    }
    ensures{
    N.numof (fun _ x -> x = false) result 0 (Array.length result) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    0
    +
    N.numof (fun _ x -> x = false) result (i+1) (Array.length result)
    }
    ensures {  
      N.numof (fun _ x -> x = false) a 0 (Array.length a) >
      N.numof (fun _ x -> x = false) result 0 (Array.length result)
    }
  =
    a[i<- true]

  lemma numof_lemma:
    forall a: array bool, i: int. 
    0 <= i < Array.length a -> (a[i] = false) ->
    N.numof (fun _ x -> x = false) (a[i<-true]) 0 a[i<-true].length <
    N.numof (fun _ x -> x = false) a 0 a.length

  let dfs (g: Graph.t) (v': int): (result: list int)
    requires { 0 <= v' < Array.length g }
    requires { Graph.safe_graph g }
  =
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in

    let rec branch v (ghost pt: path)
      requires{ 0 <= v < Graph.size g }
      requires{ forall i.  0 <= i < visited.length -> not visited[i] -> not mem i (!accessible) }
      requires{ forall i.  0 <= i < visited.length -> visited[i] -> mem i (!accessible) }
      requires{ forall i. 0 <= i < visited.length -> visited[i] -> mem i (!accessible) }
      requires{ 
          forall i. 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p
       } 
      requires{ path g v' v pt } 
      ensures { nv visited <= nv (old visited) }
      ensures { forall i. mem i (old (!accessible)) -> mem i (!accessible) }
      ensures { forall i.  0 <= i < visited.length -> old visited[i] -> visited[i] }
      
      (*ensures {
        forall i: int, p: path. 
          (forall n: int. mem n p -> 0 <= n < (old visited).length -> not (old visited)[n])
          ->
          path g v i p -> mem i (!accessible)
      }*)
      
      ensures{ 
          forall i. 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p
      } 
      
      ensures{visited[v]}
      ensures {mem v (!accessible) }
      ensures{ forall i. 0 <= i < visited.length -> not visited[i] -> not mem i (!accessible) }
      ensures{ forall i. 0 <= i < visited.length -> visited[i] -> mem i (!accessible) }
      variant { nv visited, 0 }
    =
      if not (visited[v]) then begin
        assert { AEQ.array_eq (old visited) visited };
        visited[v] <- true;
        assert { (old visited)[v] = false };
        assert { visited[v] = true };
        assert { AEQ.array_eq (old visited) visited[v <- false] };
        assert { 
          N.numof (fun _ x -> x = false) visited 0 (Array.length visited) <
          N.numof (fun _ x -> x = false) (old visited) 0 (Array.length (old visited))
        };
       

        accessible := Cons v !accessible;
        let succs = Graph.succ g v in
        label L in
        assert{ visited[v] /\ path g v' v pt };
        assert{           
        forall i . 0 <= i < old visited.length -> old visited[i] -> 
          exists p: path. path g v' i p
          };
        assert { AEQ.array_eq (old visited) visited[v <- false] };
         assert{ 
          forall i . 
          (i = v -> path g v' v pt) /\ (i <> v -> 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p)
         };
        assert{ 
          forall i . 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p
         };
        loop succs Nil v pt;
        
        assert { forall i. mem i ((!accessible) at L) -> mem i (!accessible) };
        assert { mem v ((!accessible) at L) -> mem v (!accessible) };
        assert{ mem v (!accessible) };
       
        
      end
       
    with loop l (ghost preces: list int) (ghost prec: int) (ghost pt: path)
      requires { safe_neighbours l g }
      requires{ forall i. mem i l -> mem i (Graph.succ g prec) }
      requires{ path g v' prec pt }
      requires{ forall i.  0 <= i < visited.length ->  not visited[i] -> not mem i (!accessible) }
      requires{ forall i.  0 <= i < visited.length ->  visited[i] -> mem i (!accessible) }
      requires{
          forall i . 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p
      }
      ensures { nv visited <= nv (old visited) }
      ensures { forall i. mem i (old (!accessible)) -> mem i (!accessible) }
      ensures { forall i.  0 <= i < visited.length ->  old visited[i] -> visited[i] }
      ensures{ forall i.  0 <= i < visited.length ->  visited[i] -> mem i (!accessible) }
      ensures{ 
          forall i. 0 <= i < visited.length -> visited[i] -> 
          exists p: path. path g v' i p
      } 
      (*ensures {
        forall i j: int, p: path.
        mem j l
        ->
        (forall n: int. mem n p -> 0 <= n < (old visited).length -> not (old visited)[n])
        -> path g j i p -> mem i (!accessible)
      }*)
      
      
      ensures{ forall i.  0 <= i < visited.length -> not visited[i] -> not mem i (!accessible) }
      ensures { forall n: int. mem n l -> mem n (!accessible) }
      variant { nv visited, L.length l }
    =
      match l with 
        | Nil -> ()
        | Cons neighbour s -> 

          
          
          assert{
          1 <= L.length pt /\ v' = Nth.nth 0 pt /\
           prec = Nth.nth (L.length pt - 1) pt /\
          (forall i. 0 <= i < L.length pt
          -> 0 <= Nth.nth i pt < Graph.size g) 
          /\
          (forall i. 0 <= i < L.length pt - 1 
          -> mem (Nth.nth (i+1) pt) (Graph.succ g (Nth.nth i pt)))
          };  
          
          assert { mem neighbour (Graph.succ g prec) };
          assert{ L.length APP.(pt ++ Cons neighbour Nil)  = 1 + L.length pt};
          assert{ L.length pt > 0 };
          assert{ Nth.nth (L.length pt - 1 ) pt = Nth.nth (L.length pt - 2 ) (APP.(pt ++ Cons neighbour Nil)) };
          assert{ Nth.nth (L.length pt - 2 ) (APP.(pt ++ Cons neighbour Nil)) = prec }    ;
          assert{ Nth.nth (L.length pt - 1 ) (APP.(pt ++ Cons neighbour Nil)) = neighbour }  ;      
          
          assert{
          1 <= L.length (APP.(pt ++ Cons neighbour Nil)) /\ v' = Nth.nth 0 (APP.(pt ++ Cons neighbour Nil)) /\
           neighbour = Nth.nth (L.length (APP.(pt ++ Cons neighbour Nil)) - 1) (pt ++ Cons neighbour Nil) /\
          (forall i. 0 <= i < L.length (pt ++ Cons neighbour Nil) 
          -> 0 <= Nth.nth i (pt ++ Cons neighbour Nil) < Graph.size g) 
          /\
          (forall i. 0 <= i < L.length (pt ++ Cons neighbour Nil) - 1 
          -> mem (Nth.nth (i+1) (pt ++ Cons neighbour Nil)) (Graph.succ g (Nth.nth i (pt ++ Cons neighbour Nil))))
          };
          assert{ path g v' neighbour (APP.(pt ++ Cons neighbour Nil))};
          branch neighbour (APP.(pt ++ Cons neighbour Nil));
          (*assert {
            forall i: int, p: path. 
            (forall n: int. mem n p -> not (old visited)[n])
            ->
            path g neighbour i p -> mem i (!accessible)
          };*)
          assert{ mem neighbour (!accessible) };
          
          label Z in
          loop s (Cons neighbour preces) prec pt;
          
          (*assert {
            forall i j: int, p: path.
            mem j l
            ->
            (forall n: int. mem n p -> 0 <= n < (old visited).length -> not (old visited)[n])
            -> path g j i p -> mem i (!accessible)
            
          };*)

      end;
    in
    branch v' (Cons v' Nil);
    !accessible
end