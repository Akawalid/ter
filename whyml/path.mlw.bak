module Path
  use ref.Ref
  use int.Int
  use list.Length as L
  use list.Mem
  use list.List
  use list.HdTl as Hdtl
  use list.NthNoOpt as Nth
  use array.Array
  use graph2.Graph   
  use array.NumOf as N
  use array.ArrayEq as AEQ

  type path = list int

  predicate path (g: Graph.t) (x y: int) (p: path)
  = 1 <= L.length p /\ x = Nth.nth 0 p /\ y = Nth.nth (L.length p - 1) p /\
    (forall i. 0 <= i < L.length p -> 0 <= Nth.nth i p < Graph.size g) /\
    (forall i. 0 <= i < L.length p - 1 -> mem (Nth.nth (i+1) p) (Graph.succ g (Nth.nth i p)))

  lemma path_extension: forall g: Graph.t, v j i: int, p: path.
    0 <= v < Graph.size g -> 0 <= j < Graph.size g -> 
    mem j (Graph.succ g v) -> path g j i p -> 
    path g v i (Cons v p)
  
  function nv (visited: array bool): int = N.numof (fun _ a -> a = false) visited 0 (Array.length visited)
  
  lemma numof_concat:
    forall a: array bool, l m r f.
      0 <= l <= m <= r <= Array.length a ->
      N.numof f a l r = N.numof f a l m + N.numof f a m r

let lemma numof_update (a: array bool) (i: int) : (array bool)
    requires { 0 <= i < Array.length a }
    requires { a[i] = false }
    ensures { result = a[i<- true] }
    ensures {
      N.numof (fun _ x -> x = false) a 0 i = 
      N.numof (fun _ x -> x = false) result 0 i
    }
    ensures {
      N.numof (fun _ x -> x = false) a (i+1) (Array.length a) = 
      N.numof (fun _ x -> x = false) result (i+1) (Array.length a)
    }
    ensures { 
      N.numof (fun _ x -> x = false) a i (i+1) = 1
    }
    ensures { 
      N.numof (fun _ x -> x = false) result i (i+1) = 0
    }
    ensures{
    N.numof (fun _ x -> x = false) a 0 (Array.length a) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    1
    +
    N.numof (fun _ x -> x = false) a (i+1) (Array.length a)
    }
    ensures{
    N.numof (fun _ x -> x = false) result 0 (Array.length result) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    0
    +
    N.numof (fun _ x -> x = false) result (i+1) (Array.length result)
    }
    ensures {  
      N.numof (fun _ x -> x = false) a 0 (Array.length a) >
      N.numof (fun _ x -> x = false) result 0 (Array.length result)
    }
  =
    a[i<- true]

  lemma numof_lemma:
    forall a: array bool, i: int. 
    0 <= i < Array.length a -> (a[i] = false) ->
    N.numof (fun _ x -> x = false) (a[i<-true]) 0 a[i<-true].length <
    N.numof (fun _ x -> x = false) a 0 a.length

  let dfs (g: Graph.t) (v: int): (result: list int)
    requires { 0 <= v < Array.length g }
    requires { Graph.safe_graph g }
  =
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in

    let rec branch v
      requires{ 0 <= v < Graph.size g }
      ensures { nv visited <= nv (old visited) }
      ensures { forall i. mem i (old (!accessible)) -> mem i (!accessible) }
      ensures {
        (old visited)[v]
        \/ forall i: int, p: path. path g v i p -> mem i (!accessible)
      }
      ensures { mem v (!accessible) }
      variant { nv visited, 0 }
    =
      if not (visited[v]) then begin
        assert { AEQ.array_eq (old visited) visited };
        visited[v] <- true;
        assert { (old visited)[v] = false };
        assert { visited[v] = true };
        assert { AEQ.array_eq (old visited) visited[v <- false] };
        assert { 
          N.numof (fun _ x -> x = false) visited 0 (Array.length visited) <
          N.numof (fun _ x -> x = false) (old visited) 0 (Array.length (old visited))
        };

        accessible := Cons v !accessible;
        let succs = Graph.succ g v in
        loop (succs);
 
        assert{     
        forall i: int, p: path. path g v i (Cons v p) -> L.length p >= 1 
        -> exists n. mem n (Graph.succ g v) /\ path g n i p
         };
         
        assert{ forall i: int, p: path. path g v i p -> mem i (!accessible) };
      end
    with loop l 
      requires { safe_neighbours l g }
      ensures { nv visited <= nv (old visited) }
      ensures { forall i. mem i (old (!accessible)) -> mem i (!accessible) }
      ensures {
        forall i j: int, p: path. 
        mem j l
        -> path g j i p -> mem i (!accessible)
      }
      ensures { forall n: int. mem n l -> mem n (!accessible) }
      variant { nv visited, L.length l }
    =
      match l with 
        | Nil -> ()
        | Cons neighbour s -> 
          branch neighbour;
          assert {
            forall i: int, p: path. 
            not((old visited)[neighbour])
            -> mem neighbour l
            -> path g neighbour i p -> mem i (!accessible)
          };
          loop s;
      end;
    in
    branch v;
    !accessible
end
(*module Path
  use ref.Ref
  use int.Int
  use list.Length as L
  use list.Mem
  use list.List
  use list.NthNoOpt as Nth
  use array.Array
  use graph2.Graph   
  use array.NumOf as N
  use array.ArrayEq as AEQ

  type path = list int

  predicate path (g: Graph.t) (x y: int) (p: path)
  = 1 <= L.length p /\ x = Nth.nth 0 p /\ y = Nth.nth (L.length p - 1) p /\
    (forall i. 0 <= i < L.length p -> 0 <= Nth.nth i p < Graph.size g) /\
    (forall i. 0 <= i < L.length p - 1 -> mem (Nth.nth (i+1) p) (Graph.succ g (Nth.nth i p)))

  lemma path_extension: forall g: Graph.t, v j i: int, p: path.
    0 <= v < Graph.size g -> 0 <= j < Graph.size g -> 
    mem j (Graph.succ g v) -> path g j i p -> 
    path g v i (Cons v p)
  
  function nv (visited: array bool): int = N.numof (fun _ a -> a = false) visited 0 (Array.length visited)
  
  lemma numof_concat:
    forall a: array bool, l m r f.
      0 <= l <= m <= r <= Array.length a ->
      N.numof f a l r = N.numof f a l m + N.numof f a m r

  let lemma numof_update (a: array bool) (i: int) : (array bool)
    requires { 0 <= i < Array.length a }
    requires { a[i] = false }
    ensures { result = a[i<- true] }
    ensures {
      N.numof (fun _ x -> x = false) a 0 i = 
      N.numof (fun _ x -> x = false) result 0 i
    }
    ensures {
      N.numof (fun _ x -> x = false) a (i+1) (Array.length a) = 
      N.numof (fun _ x -> x = false) result (i+1) (Array.length a)
    }
    ensures { 
      N.numof (fun _ x -> x = false) a i (i+1) = 1
    }
    ensures { 
      N.numof (fun _ x -> x = false) result i (i+1) = 0
    }
    ensures{
    N.numof (fun _ x -> x = false) a 0 (Array.length a) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    N.numof (fun _ x -> x = false) a i (i+1)
    +
    N.numof (fun _ x -> x = false) a (i+1) (Array.length a)
    }
    ensures{
    N.numof (fun _ x -> x = false) result 0 (Array.length result) = 
    N.numof (fun _ x -> x = false) a 0 i 
    +
    N.numof (fun _ x -> x = false) result i (i+1)
    +
    N.numof (fun _ x -> x = false) result (i+1) (Array.length result)
    }
    ensures {  
      N.numof (fun _ x -> x = false) a 0 (Array.length a) >
      N.numof (fun _ x -> x = false) result 0 (Array.length result)
    }
  =
    a[i<- true]
    

  lemma numof_lemma:
    forall a: array bool, i: int. 
    0 <= i < Array.length a -> (a[i] = false) ->
    N.numof (fun _ x -> x = false) (a[i<-true]) 0 a[i<-true].length <
    N.numof (fun _ x -> x = false) a 0 a.length
    
  let dfs (g: Graph.t) (v: int): (result: list int)
    requires { 0 <= v < Array.length g }
    requires { Graph.safe_graph g }
  =
    let visited = Array.make (Graph.size g) false in
    let ghost state = Array.make (Graph.size g) 0 in
    (*
    0: unvisited,
    1: in treatement,
    2: treated
    *)
    let accessible = ref Nil in

    let rec branch v
      requires{ 0 <= v < Graph.size g }
      ensures { nv visited <= nv (old visited) }
      ensures {
        (old visited)[v]
        (*state[v] = 1*)
        \/ forall i: int, p: path. path g v i p -> mem i (!accessible)
      }
      variant { nv visited, 0 }
    =
      if not (visited[v]) then begin
        assert { AEQ.array_eq (old visited) visited };
        assert { AEQ.array_eq (old state) state };
        visited[v] <- true;
        state[v] <- 1;
        assert { (old visited)[v] = false };
        assert { visited[v] = true };
        assert { AEQ.array_eq (old visited) visited[v <- false] };
        assert { 
          N.numof (fun _ x -> x = false) visited 0 (Array.length visited) <
          N.numof (fun _ x -> x = false) (old visited) 0 (Array.length (old visited))
        };

        accessible := Cons v !accessible;
        let succs = Graph.succ g v in
        loop succs;
        state[v] <- 2;
        (* assert {
          forall i j: int, p: path. 
          not((old visited)[j])
          -> mem j (succs)
          -> path g j i p -> mem i (!accessible)
        }; *) (* should, but doesn't get verified, even tho ensured by loop ? *)
        assert{ forall i: int. mem i succs -> mem i (!accessible) };
        assert { forall i: int, p: path. path g v i p -> mem i (!accessible) };
      end
    with loop l 
      requires { safe_neighbours l g }
      ensures { nv visited <= nv (old visited) }
      ensures {
        forall i j: int, p: path. 
        mem j l ->
        not((old visited)[j])
        (*not(state[v] = 1)*)
        -> path g j i p -> mem i (!accessible)
      }
      ensures{ forall i. mem i l -> mem i (!accessible) }
      variant { nv visited, L.length l }
    =
      match l with 
        | Nil -> ()
        | Cons neighbour s -> 
          branch neighbour;
          assert {
            forall i: int, p: path.
            not((old visited)[neighbour])
            (*not(state[v] = 1)*)
            -> path g neighbour i p -> mem i (!accessible)
          };
          loop s;
      end;
    in
    branch v;
    !accessible
end*)