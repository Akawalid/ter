module Path
  use ref.Ref
  use int.Int
  use list.Length as L
  use list.Mem
  use list.List
  use list.NthNoOpt as Nth
  use array.Array
  use graph2.Graph   
  use array.NumOf as N
  use array.ArrayEq as AEQ

  type path = list int

  predicate path (g: Graph.t) (x y: int) (p: path)
  = 1 <= L.length p /\ x = Nth.nth 0 p /\ y = Nth.nth (L.length p - 1) p /\
    (forall i. 0 <= i < L.length p -> 0 <= Nth.nth i p < Graph.size g) /\
    (forall i. 0 <= i < L.length p - 1 -> mem (Nth.nth (i+1) p) (Graph.succ g (Nth.nth i p)))

  lemma path_extension: forall g: Graph.t, v j i: int, p: path.
    0 <= v < Graph.size g -> 0 <= j < Graph.size g -> 
    mem j (Graph.succ g v) -> path g j i p -> 
    path g v i (Cons v p)
  
  function nv (visited: array bool): int = N.numof (fun _ a -> a = false) visited 0 (Array.length visited)
  
  lemma numof_concat:
    forall a: array bool, l m r f.
      0 <= l <= m <= r <= Array.length a ->
      N.numof f a l r = N.numof f a l m + N.numof f a m r

  let lemma numof_update (a: array bool) (i: int) : (array bool)
    requires { 0 <= i < Array.length a }
    requires { a[i] = false }
    ensures { result = a[i<- true] }
    ensures {
      N.numof (fun _ x -> x = false) a 0 i = 
      N.numof (fun _ x -> x = false) result 0 i
    }
    ensures {
      N.numof (fun _ x -> x = false) a (i+1) (Array.length a) = 
      N.numof (fun _ x -> x = false) result (i+1) (Array.length a)
    }
    ensures { 
      N.numof (fun _ x -> x = false) a i (i+1) = 1
    }
    ensures { 
      N.numof (fun _ x -> x = false) result i (i+1) = 0
    }
    ensures {  
      N.numof (fun _ x -> x = false) a 0 (Array.length a) >
      N.numof (fun _ x -> x = false) result 0 (Array.length result)
    }
  =
    a[i<- true]

  lemma numof_lemma:
    forall a: array bool, i: int. 
    0 <= i < Array.length a -> (a[i] = false) ->
    N.numof (fun _ x -> x = false) (a[i<-true]) 0 a[i<-true].length <
    N.numof (fun _ x -> x = false) a 0 a.length

  lemma accessible_invariant:
    forall g: Graph.t, p: path, visited: array bool, accessible: list int, v: int.
    0 <= v < Graph.size g ->
    Graph.safe_graph g ->
    (forall j. 0 <= j < Graph.size g -> visited[j] = true -> mem j accessible) ->
    (forall j k. 0 <= j < Graph.size g -> visited[j] = true -> 
    path g j k p -> mem k accessible) ->
    path g v i p ->
    mem i accessible

  lemma reachable_nodes_in_accessible:
    forall g: Graph.t, v i: int, p: path, visited: array bool, accessible: list int.
    path g v i p ->
      (forall j. 0 <= j < Graph.size g -> visited[j] = true -> mem j accessible) ->
        (forall j k. 0 <= j < Graph.size g -> visited[j] = true -> 
          path g j k p -> mem k accessible) ->
            mem i accessible
  = 
    accessible_invariant g visited accessible v

  let dfs (g: Graph.t) (v: int): (result: list int)
    requires { 0 <= v < Array.length g }
    requires { Graph.safe_graph g }
  =
    let visited = Array.make (Graph.size g) false in
    let accessible = ref Nil in

    let rec branch v
      requires{ 0 <= v < Graph.size g }
      ensures { nv visited <= nv (old visited) }
      ensures {
        (old visited)[v]
        \/ forall i: int, p: path. path g v i p -> mem i (!accessible)
      }
      variant{ nv visited, 0 }
    =
      if not (visited[v]) then begin
        assert { AEQ.array_eq (old visited) visited };
        visited[v] <- true;
        assert { (old visited)[v] = false };
        assert { visited[v] = true };
        assert { AEQ.array_eq (old visited) visited[v <- false] };
        assert { 
          N.numof (fun _ x -> x = false) visited 0 (Array.length visited) <
          N.numof (fun _ x -> x = false) (old visited) 0 (Array.length (old visited))
        };

        accessible := Cons v !accessible;
        loop (Graph.succ g v);
        assert { forall i: int, p: path. path g v i p -> mem i (!accessible) }
      end
    with loop l 
      requires { safe_neighbours l g }
      ensures { nv visited <= nv (old visited) }
      ensures {
        forall i j: int, p: path. 
        not(old visited[j])
        -> mem j l 
        -> path g j i p -> mem i (!accessible)
      }
      variant { nv visited, L.length l }
    =
      match l with 
        | Nil -> ()
        | Cons neighbour s -> 
          branch neighbour;
          loop s
      end;
        (*
          assert {
          forall i j: int, p: path. 
          not(old visited[j])
          -> mem j l 
          -> path g j i p -> mem i (!accessible)
          }
        *)
    in
    branch v;
    !accessible
end